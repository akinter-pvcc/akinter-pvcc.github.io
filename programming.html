<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Chapter 5: Programming Algorithms & Software Testing</title>
    </head>
    <body style="color: #092327; background-color: #00A9A5;font-family:tahoma,verdana;">
        <h4>Phases of computer program development:</h4>
        <ol>
            <li>Phase 1: Understand the probblem</li>
            <li>Phase 2: Design an algorithm to solve the problem</li>
            <li>Phase 3: Write the program code in appropriate language based on the algorithm</li>
            <li>Phase 4: Enter the program and save</li>
            <li>Phase 5: Execute the program</li>
            <li>Phase 6: Test the program, find errors and debug, then retest</li>
            <li>Phase 7: Document and evaluate the program</li>
        </ol>
        <h4>Program structures:</h4>
        <ul>
            <li>Sequential structure: Top-down execution</li>
            <li>Decision structures: if/then/else</li>
            <li>Iterative (looping):</li>
            <ul>
                <li>while loop: continue looping as long as something is true</li>
                <li>repeat/until loop: continue looping until something is true</li>
                <li>for loop: loop a given number of times</li>
            </ul>
            <li>Recursive structures:</li>
            <ul>
                <li>Repeat a set of instructions as a substast of itself</li>
                <li>Repetition continues until:</li>
                <ul>
                    <li>degenerative case, which is a termination condition, is met</li>
                    <li>(degenerative case is also called a "base case")</li>
                </ul>
            </ul>
        </ul>
        <h4>Two classic programming/database problems</h4>
        <ul>
            <li>Sorting: Descending order/Ascending order</li>
            <ul>
                <li>Sorting numbers</li>
                <li>Sorting strings (in accordance with ASCII values)</li>
            </ul>
            <li>Searching: find specific that meet a certain criteria</li>
            <ul>
                <li>In database:</li>
                <ul>
                    <li>Filters: temprary search</li>
                    <li>Queries: search criteria are saved so they don't have to be recreated</li>
                </ul>
            </ul>
        </ul>
        <h4>Two classic program goals:</h4>
        <ul>
            <li>Efficiency: Program taxes minimal time and/or resources</li>
            <li>Correctness: Program runs in expected ways and works for all expected conditions</li>
        </ul>
    </body>
    <h4>Software testing and verification</h4>
    <table style="color:#90C2E7; background-color: #0B5351;">
        <th>Kinds of tests:</th>
        <tr>
            <td>Acceptance testing</td>
            <td>Verifying whether the whole system works as intended.</td>
        </tr>
        <tr>
            <td>Integration testing:</td>
            <td>Ensuring that software components or functions operate together.</td>
        </tr><tr>
            <td>Unit testing:</td>
            <td>Validating that each software unit performs as expected. A unit is the smallest testable component of an application.</td>
        </tr><tr>
            <td>Functional testing:</td>
            <td>Checking functions by emulating business scenarios, based on functional requirements. Black-box testing is a common way to verify functions.</td>
        </tr><tr>
            <td>Performance testing:</td>
            <td>Testing how the software performs under different workloads. Load testing, for example, is used to evaluate performance under real-life load conditions.</td>
        </tr><tr>
            <td>Regression testing:</td>
            <td>Checking whether new features break or degrade functionality. Sanity testing can be used to verify menus, functions and commands at the surface level, when there is no time for a full regression test.</td>
        </tr><tr>
            <td>Stress testing:</td>
            <td>Testing how much strain the system can take before it fails. Considered to be a type of non-functional testing.</td>
        </tr><tr>
            <td>Usability testing</td>
            <td>Validating how well a customer can use a system or web application to complete a task.</td>
        </tr>
        <th>Software testing is done to detect</th>
        <tr>
            <td>
                <ul>
                    <li>Architectural flaws</li>
                    <li>Poor design decisions</li>
                    <li>Invalid or incorrect functionality</li>
                    <li>Security vulnerabilities</li>
                    <li>Invalid or incorrect functionality</li>
                    <li>Scalability issues</li>
                </ul> 
            </td>
        </tr></trd> 
        </tr>
        <th>Testing best practices:</th>
        <tr>
            <td>Continous testing</td>
            <td>Project teams rely on test automation to test each build as a part of the deployment process. </td>
        </tr><tr>
            <td>Configuartion management</td>
            <td>Organizations centrally maintain test assets and track wat software builds to test.</td>
        </tr><tr>
            <td>Service virtualization</td>
            <td>Simulates the services and systems that are missing or not yet completed, enabling teams to reduce dependencies and test sooner.</td>
        </tr><tr>
            <td>Defect or "bug tracking"</td>
            <td>Automated tools allow teams to track defects, measure their scope and impact, and uncover related issues.</td>
        </tr><tr>
            <td>Metrics and reporting</td>
            <td>Reporting and analytics enable team members to share status, goals and test results. </td>
        </tr>
    </table>
</html>